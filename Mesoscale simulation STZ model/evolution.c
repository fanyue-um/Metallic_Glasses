/* evolution.c */
#include "bmg.h"
#include "my_fft.h"

void UpdateSOC(void){
	int ix, iy;
	int avlanAllCounter = 0;
	real SOCAllelast = 0.;

	MPI_Barrier(MPI_COMM_WORLD);
	MPI_Allreduce(&avlanCounter, &avlanAllCounter, 1, MPI_INT,
			MPI_SUM, MPI_COMM_WORLD);
	if(avlanAllCounter > sizeSOC){
		for(ix=0; ix<2; ix++){
			countSOC[ix] = (int *)realloc((void *)countSOC[ix], avlanAllCounter*sizeof(int));
			for(iy=sizeSOC; iy<avlanAllCounter; iy++){
				if(ix==0)
					countSOC[ix][iy] = iy+1;
				else
					countSOC[ix][iy] = 0;
			}
		}
		countSOC[1][avlanAllCounter-1] = 1;
		sizeSOC = avlanAllCounter;
	}
	else if(avlanAllCounter > 0)
		countSOC[1][avlanAllCounter-1] += 1;

	avlanCounter = 0;

	MPI_Barrier(MPI_COMM_WORLD);
	MPI_Allreduce(&SOCelast, &SOCAllelast, 1, MPI_real,
			MPI_SUM, MPI_COMM_WORLD);
	if(fabs(SOCAllelast) > EPSILON){
		sizeElaSOC++;
		for(ix=0; ix<2; ix++){
			elastSOC[ix] = (real *)realloc((void *)elastSOC[ix], sizeElaSOC*sizeof(real));
		}
		elastSOC[0][sizeElaSOC-1] = totime;
		elastSOC[1][sizeElaSOC-1] = SOCAllelast;
		SOCelast = 0.;
	}

	return;
}/* end UpdateSOC() */

void athermal_plasticity(void){
	astep++;
	int m, i, j, idx, mm;
	real minQ;
	real DWork;
	real tmpStress[DE], tmpStrain[DE];

	if(flag > 0){
		space_loop{
			idx = i*NY + j;
			mm = 0;
			minQ = Q[mm][idx];
			for(m=0; m<MODES; m++){
				if(minQ > Q[m][idx]){
					mm = m;
					minQ = Q[mm][idx];
				}
			}
			if(minQ < 0 || fabs(minQ)<0.33){
				DWork = (Sigma[0][idx] * DEps0[mm][0][idx] + Sigma[1][idx] * DEps0[mm][1][idx] +
						2 * Sigma[2][idx] * DEps0[mm][2][idx]) * VOXEL0 * 1e-18 * J_IN_EV;
				SOCelast += fabs(DWork);
//	printf("test1");
				VoxelShearTransform(mm, idx);
				avlanCounter++;
#ifdef MICRO_MEMORY
				PreSelectMode[idx] = mm;
#endif
			}
		}
	}

	MPI_Barrier(MPI_COMM_WORLD);
#ifdef INHOM_ELAST
	//HomogeneousStressSolver(lambda, mu, Eps0, EpsAvg,
	//		XR, TotEps, Sigma, Stress, 0);
	InhomogeneousStressSolver(Lambda, Mu,
      Eps0, EpsAvg,
      lambda, mu,
			XR, TotEps, Sigma, Stress, 0);
#else
	HomStressSolver();
#endif

#ifndef NO_SUBTRACT_ERROR
	tmpStress[0] = 0.0;	tmpStress[1] = Stress[1]; tmpStress[2] = Stress[2];
#else
	tmpStress[0] = 0.0;	tmpStress[1] = 0.0; tmpStress[2] = 0.0;
#endif
	isotropicinv(lambda, mu, tmpStress, tmpStrain);
	for(i=0; i<DE; i++) EpsAvg[i] -= tmpStrain[i];

	return;
}/* end athermal_plasticity() */

void KMC(void){
	real t_kmc = 0;
	real t_kmcAll = 0.;
	real dice;
	real tmpb = 0;
	int m, i, j, de, idx;
	int min, max, mid, event;
	real *rate;
	real tmpStress[DE] = {0};
	real tmpStrain[DE] = {0};
	int bflag=0;
	int bflagAll = 0;
//	real DWork = 0.;
  real chosenQ = 0.;
  real chosenQAll = 0.;
  int chosenM = 0;
  int chosenMAll = 0;

	rate = (real *)malloc(MODES*lsize * sizeof(real));
	for(m=0; m<MODES; m++){
		space_loop{
			idx = i*NY + j;
			de = (m*lnx + i)*NY + j;
			rate[de] = VOXEL0 * TRIAL_FREQUENCY * exp(-Q[m][idx]/kT);
			t_kmc += rate[de];
		}
	}
	MPI_Barrier(MPI_COMM_WORLD);

	MPI_Allreduce(&t_kmc, &t_kmcAll, 1, MPI_DOUBLE,
			MPI_SUM, MPI_COMM_WORLD);

	t_kmc = 1/t_kmcAll;

	if(t_kmc < dt){
		kstep++;
		
		/* thermal plasticity */
		/* dice is generated by pe#0 and passed to others */
		if(rank == 0){
			dice = gsl_rng_uniform(r);
			for(i=1; i<totnodes; i++)
				MPI_Send(&dice, 1, MPI_DOUBLE, i, 1, MPI_COMM_WORLD);
		}
		else
			MPI_Recv(&dice, 1, MPI_DOUBLE, 0, 1, MPI_COMM_WORLD, &status);

		/* normalize */
		idx = MODES*lsize;
		for(i=0; i<idx; i++) rate[i] *= t_kmc;
		/* cumulative sum */
		for(i=1; i<idx; i++) rate[i] += rate[i-1];
		if(rank == 0)
			MPI_Send(&rate[idx-1], 1, MPI_DOUBLE,
					1, 0, MPI_COMM_WORLD);
		else if(rank != (totnodes-1)){
			MPI_Recv(&tmpb, 1, MPI_DOUBLE,
					rank-1, rank-1, MPI_COMM_WORLD, &status);
			for(i=0; i<idx; i++) rate[i] += tmpb;
			MPI_Send(&rate[idx-1], 1, MPI_DOUBLE,
					rank+1, rank, MPI_COMM_WORLD);
		}
		else{
			MPI_Recv(&tmpb, 1, MPI_DOUBLE,
					rank-1, rank-1, MPI_COMM_WORLD, &status);
			for(i=0; i<idx; i++) rate[i] += tmpb;
		}

		/* binary search */
		min = 0;
		max = MODES * lsize - 1;
		event = 0;
		if((rate[max]>=dice)&&(rate[min]<dice)){
			bflag++;
			while(1){
				mid = min + (max - min)/2;
				if((dice <= rate[mid])&&(dice>rate[mid-1])){
					event = mid;
					break;
				}
				else if(dice > rate[mid])
					min = mid + 1;
				else if(dice < rate[mid-1])
					max = mid;
				if(max < min){
					printf("[PE#%d] KMC: binary search failed!\n", rank);
					MPI_Abort(MPI_COMM_WORLD, -1);
				}
			}

			m = (int)(floor((real)event/lsize));
			idx = event - m*lsize;
				
//#if defined(XTAL_VARIANTS)
//			DWork = (Sigma[0][idx] * (DEps0[m][0][idx]-Eps0[0][idx]) + Sigma[1][idx] * (DEps0[m][1][idx]-Eps0[1][idx]) +
//					2 * Sigma[2][idx] * (DEps0[m][2][idx]-Eps0[2][idx])) * VOXEL0 * 1e-18 * J_IN_EV;
//#else
//			DWork = (Sigma[0][idx] * DEps0[m][0][idx] + Sigma[1][idx] * DEps0[m][1][idx] +
//						2 * Sigma[2][idx] * DEps0[m][2][idx]) * VOXEL0 * 1e-18 * J_IN_EV;
//#endif
//			SOCelast += fabs(DWork);
//			avlanCounter++;
			VoxelShearTransform(m, idx);
      chosenQ = Q[m][idx];
      chosenM = MRO[idx];
#ifdef MICRO_MEMORY
			PreSelectMode[idx] = m;
#endif
		}
		else if((dice>tmpb)&&(dice<=rate[0])){
			bflag++;
			m = 0; idx = 0;
//			DWork = (Sigma[0][idx] * DEps0[m][0][idx] + Sigma[1][idx] * DEps0[m][1][idx] +
//					2 * Sigma[2][idx] * DEps0[m][2][idx]) * VOXEL0 * 1e-18 * J_IN_EV;
//			SOCelast += fabs(DWork);
//			avlanCounter++;
			VoxelShearTransform(m, idx);
      chosenQ = Q[m][idx];
      chosenM = MRO[idx];
#ifdef MICRO_MEMORY
			PreSelectMode[idx] = m;
#endif
		}



		MPI_Barrier(MPI_COMM_WORLD);
		MPI_Allreduce(&bflag, &bflagAll, 1, MPI_INT,
				MPI_SUM, MPI_COMM_WORLD);
		if(bflagAll==0){
			printf("KMC failed to locate a activation mode!\n");
			MPI_Abort(MPI_COMM_WORLD, -1);
		}

		MPI_Barrier(MPI_COMM_WORLD);
		MPI_Allreduce(&chosenQ, &chosenQAll, 1, MPI_real,
				MPI_SUM, MPI_COMM_WORLD);
		MPI_Barrier(MPI_COMM_WORLD);
		MPI_Allreduce(&chosenM, &chosenMAll, 1, MPI_INT,
				MPI_SUM, MPI_COMM_WORLD);
    /* record actual activation energy involved in transformaion */
    if(rank==0) fprintf(fq, "%d\t%.6e\n", chosenMAll, chosenQAll);
    fflush(fq);

		MPI_Barrier(MPI_COMM_WORLD);
#ifdef HEAT_CONDUCT
		HeatConducting(thermal_diffusivity * t_kmc);
#endif
#ifdef INHOM_ELAST
	//HomogeneousStressSolver(lambda, mu, Eps0, EpsAvg,
	//		XR, TotEps, Sigma, Stress, 0);
	InhomogeneousStressSolver(Lambda, Mu,
      Eps0, EpsAvg,
      lambda, mu,
			XR, TotEps, Sigma, Stress, 0);
#else
	HomStressSolver();
#endif

	
#if defined(COMPRESSION)
#ifndef NO_SUBTRACT_ERROR
		tmpStress[0] = 0.0;	tmpStress[1] = Stress[1]; tmpStress[2] = Stress[2];
#else
		tmpStress[0] = 0.0;	tmpStress[1] = 0.0; tmpStress[2] = 0.0;
#endif
		EpsAvg[0] += (-strainrate*t_kmc*1 );
		EpsAvg[1] += (strainrate*t_kmc*(nu) );
		isotropicinv(lambda, mu, tmpStress, tmpStrain);

		EpsAvg[0] += (-strainrate*t_kmc*1 - tmpStrain[0]);
		EpsAvg[1] += (strainrate*t_kmc*(nu) - tmpStrain[1]);
		EpsAvg[2] += (- tmpStrain[2]);

		Stress[0] += -E*strainrate*t_kmc;
		space_loop{
			idx = i*NY + j;
			Sigma[0][idx] += -E*strainrate*t_kmc;
		}
#elif defined(TENSION)
#ifndef NO_SUBTRACT_ERROR
		tmpStress[0] = 0.0;	tmpStress[1] = Stress[1]; tmpStress[2] = Stress[2];
#else
		tmpStress[0] = 0.0;	tmpStress[1] = 0.0; tmpStress[2] = 0.0;
#endif
		isotropicinv(lambda, mu, tmpStress, tmpStrain);

		EpsAvg[0] += (strainrate*t_kmc*1 - tmpStrain[0]);
		EpsAvg[1] += (strainrate*t_kmc*(-nu) - tmpStrain[1]);
		EpsAvg[2] += (- tmpStrain[2]);

		Stress[0] += E*strainrate*t_kmc;
		space_loop{
			idx = i*NY + j;
			Sigma[0][idx] += E*strainrate*t_kmc;
		}
#elif defined(SHEAR)
#ifndef NO_SUBTRACT_ERROR
		tmpStress[0] = Stress[0];	tmpStress[1] = Stress[1]; tmpStress[2] = 0;
#else
		tmpStress[0] = 0.0;	tmpStress[1] = 0.0; tmpStress[2] = 0.0;
#endif
		isotropicinv(lambda, mu, tmpStress, tmpStrain);

		EpsAvg[0] += -tmpStrain[0];
		EpsAvg[1] += -tmpStrain[1];
		EpsAvg[2] += strainrate*t_kmc;

		Stress[2] += 2*mu*strainrate*t_kmc;
		space_loop{
			idx = i*NY + j;
			Sigma[2][idx] += 2*mu*strainrate*t_kmc;
		}
#endif
		
		totime += t_kmc;
		//totime += dt;

	}
	else{
		estep++;
		/* pure elasticity */
		totime += dt;
#ifdef HEAT_CONDUCT
		HeatConducting(thermal_diffusivity * dt);
#endif

#if defined(COMPRESSION)
		EpsAvg[0] += (strainincrement * (-1));
		EpsAvg[1] += (strainincrement * (nu));
		EpsAvg[2] += (strainincrement * 0.0);

		Stress[0] += -E * strainincrement;
		space_loop{
			idx = i*NY + j;
			Sigma[0][idx] += -E*strainincrement;
		}
#elif defined(TENSION)
		EpsAvg[0] += (strainincrement * 1);
		EpsAvg[1] += (strainincrement * (-nu));
		EpsAvg[2] += (strainincrement * 0.0);

		Stress[0] += E * strainincrement;
		space_loop{
			idx = i*NY + j;
			Sigma[0][idx] += E*strainincrement;
		}
#elif defined(SHEAR)
		EpsAvg[2] += strainrate*1;

		Stress[2] += 2*mu*strainincrement;
		space_loop{
			idx = i*NY + j;
			Sigma[2][idx] += 2*mu*strainincrement;
		}
#endif
	}

	free(rate);
	return;

}/* end KMC() */

real relx_KMC(void){
	real t_kmc_pe = 0.;
	real t_kmc = 0.;
	real dice;
	real tmpb = 0.;
	int m, i, j, de, idx;
	int min, max, mid, event;
	real *rate;
	int bflag=0;
	int bflagAll=0;
	//real DWork;
	real tmpStress[DE], tmpStrain[DE];

	rate = (real *)malloc(MODES*lsize * sizeof(real));
	for(m=0; m<MODES; m++){
		space_loop{
			idx = i*NY + j;
			de = (m*lnx + i)*NY + j;
			rate[de] = VOXEL0 * TRIAL_FREQUENCY * exp(-Q[m][idx]/kT);
			t_kmc_pe += rate[de];
		}
	}
	MPI_Barrier(MPI_COMM_WORLD);

	MPI_Allreduce(&t_kmc_pe, &t_kmc, 1, MPI_DOUBLE,
			MPI_SUM, MPI_COMM_WORLD);

	t_kmc = 1/(t_kmc + EPSILON);

	/* relaxation will wait until the thermal plasticity occurs */
	if(1){
		
		/* thermal plasticity */
		/* dice is generated by pe#0 and passed to others */
		if(rank == 0){
			dice = gsl_rng_uniform(r);
			for(i=1; i<totnodes; i++)
				MPI_Send(&dice, 1, MPI_DOUBLE, i, 1, MPI_COMM_WORLD);
		}
		else
			MPI_Recv(&dice, 1, MPI_DOUBLE, 0, 1, MPI_COMM_WORLD, &status);

		/* normalize */
		idx = MODES*lsize;
		for(i=0; i<idx; i++) rate[i] *= t_kmc;
		/* cumulative sum */
		for(i=1; i<idx; i++) rate[i] += rate[i-1];
		if(rank == 0)
			MPI_Send(&rate[idx-1], 1, MPI_DOUBLE,
					1, 0, MPI_COMM_WORLD);
		else if(rank != (totnodes-1)){
			MPI_Recv(&tmpb, 1, MPI_DOUBLE,
					rank-1, rank-1, MPI_COMM_WORLD, &status);
			for(i=0; i<idx; i++) rate[i] += tmpb;
			MPI_Send(&rate[idx-1], 1, MPI_DOUBLE,
					rank+1, rank, MPI_COMM_WORLD);
		}
		else{
			MPI_Recv(&tmpb, 1, MPI_DOUBLE,
					rank-1, rank-1, MPI_COMM_WORLD, &status);
			for(i=0; i<idx; i++) rate[i] += tmpb;
		}

		/* binary search */
		min = 0;
		max = MODES * lsize - 1;
		event = 0;
		if((rate[max]>=dice)&&(rate[min]<dice)){
			bflag++;
			while(1){
				mid = min + (max - min)/2;
				if((dice <= rate[mid])&&(dice>rate[mid-1])){
					event = mid;
					break;
				}
				else if(dice > rate[mid])
					min = mid + 1;
				else if(dice < rate[mid-1])
					max = mid;
				if(max < min){
					printf("[PE#%d] KMC: binary search failed!\n", rank);
					MPI_Abort(MPI_COMM_WORLD, -1);
				}
			}

			m = (int)(floor((real)event/lsize));
			idx = event - m*lsize;
//			DWork = (Sigma[0][idx] * DEps0[m][0][idx] + Sigma[1][idx] * DEps0[m][1][idx] +
//					2 * Sigma[2][idx] * DEps0[m][2][idx]) * VOXEL0 * 1e-18 * J_IN_EV;
//			SOCelast += fabs(DWork);
//			avlanCounter++;

			VoxelShearTransform(m, idx);
		}
		else if((dice>tmpb)&&(dice<=rate[0])){
			bflag++;
			m = 0; idx = 0;
//			DWork = (Sigma[0][idx] * DEps0[m][0][idx] + Sigma[1][idx] * DEps0[m][1][idx] +
//					2 * Sigma[2][idx] * DEps0[m][2][idx]) * VOXEL0 * 1e-18 * J_IN_EV;
//			SOCelast += fabs(DWork);
//			avlanCounter++;
			VoxelShearTransform(m, idx);
		}


		MPI_Barrier(MPI_COMM_WORLD);
		MPI_Allreduce(&bflag, &bflagAll, 1, MPI_INT,
				MPI_SUM, MPI_COMM_WORLD);
		if(bflagAll==0){
			printf("KMC failed to locate a activation mode!\n");
			MPI_Abort(MPI_COMM_WORLD, -1);
		}

		MPI_Barrier(MPI_COMM_WORLD);
#ifdef HEAT_CONDUCT
		HeatConducting(thermal_diffusivity * t_kmc);
#endif
#ifdef INHOM_ELAST
	//HomogeneousStressSolver(lambda, mu, Eps0, EpsAvg,
	//		XR, TotEps, Sigma, Stress, 0);
	InhomogeneousStressSolver(Lambda, Mu,
      Eps0, EpsAvg,
      lambda, mu,
			XR, TotEps, Sigma, Stress, 0);
#else
	HomStressSolver();
#endif

		tmpStress[0] = Stress[0];	tmpStress[1] = Stress[1]; tmpStress[2] = Stress[2];
		isotropicinv(lambda, mu, tmpStress, tmpStrain);
		for(i=0; i<DE; i++) EpsAvg[i] -= tmpStrain[i];
	}


	free(rate);
	return t_kmc;
}/*end relx_KMC() */

void relx_athermal_plasticity(void){
	astep++;
	int m, i, j, idx, mm;
	real minQ;
	real DWork;
	real tmpStress[DE], tmpStrain[DE];

	if(flag > 0){
		space_loop{
			idx = i*NY + j;
			mm = 0;
			minQ = Q[mm][idx];
			for(m=0; m<MODES; m++){
				if(minQ > Q[m][idx]){
					mm = m;
					minQ = Q[mm][idx];
				}
			}
			if(minQ < 0){
				DWork = (Sigma[0][idx] * DEps0[mm][0][idx] + Sigma[1][idx] * DEps0[mm][1][idx] +
						2 * Sigma[2][idx] * DEps0[mm][2][idx]) * VOXEL0 * 1e-18 * J_IN_EV;
				SOCelast += fabs(DWork);
				VoxelShearTransform(mm, idx);
				avlanCounter++;
			}
		}
	}

	MPI_Barrier(MPI_COMM_WORLD);
#ifdef INHOM_ELAST
	//HomogeneousStressSolver(lambda, mu, Eps0, EpsAvg,
	//		XR, TotEps, Sigma, Stress, 0);
	InhomogeneousStressSolver(Lambda, Mu,
      Eps0, EpsAvg,
      lambda, mu,
			XR, TotEps, Sigma, Stress, 0);
#else
	HomStressSolver();
#endif

	tmpStress[0] = Stress[0];	tmpStress[1] = Stress[1]; tmpStress[2] = Stress[2];
	isotropicinv(lambda, mu, tmpStress, tmpStrain);
	for(i=0; i<DE; i++) EpsAvg[i] -= tmpStrain[i];

	return;
}/* end relx_athermal_plasticity() */


